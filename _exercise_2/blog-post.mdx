I made a group of posts and other resources, combined them into this huge post so I can develop style and look for my blog post pages. This is like a intro argument, starting text. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

<Step title="Something new!" no={1} />
We put step as a header and a number // and bellow we set some text (we can add text
abut we don't need it if we don't want) Search for something you know.
<Step title="Something new 2!" no={2} />
Look like something new.
<Step title="Something new 3!" no={3} />
Making of looking because of thinking.
<Step title="Something new 4!" no={4} />

While I enjoyed web development, the front-end never _fully clicked_ for me until I started using React a few years later in my first full-time job. Up until this point, most "modern web development" at the time seemed so complex. Learning React, and then starting to use Create React App, helped me finally break free from JavaScript build tool hell and focus on building great websites. This is when I started to grow exponentially as a developer.

Specializing on one specific thing (React) led to a snowball effect. Suddenly, I was becoming proficient in other related skills. Understanding the fundamentals led to faster adoption of the next layer of tools, and finally to understanding and creating my own backends and APIs.

Specializing on one specific thing (React) led to a snowball effect. Suddenly, I was becoming proficient in other related skills. Understanding the fundamentals led to faster adoption of the next layer of tools, and finally to understanding and creating my own backends and APIs.

<Steps
  list={[
    { text: "Hello world" },
    { text: "Hello world", color: "primary" },
    { text: "Hello world" },
    { text: "Hello world", color: "secondary" },
    { text: "Hello world", color: "error" },
    { text: "Hello world", color: "info" },
    { text: "Hello world", color: "neutral" },
    { text: "Hello world", color: "accent" },
  ]}
/>

Above I showed you some steps, they are cool steps

Above I showed you some steps, they are cool steps

<Steps
  list={[
    { text: "Hello world" },
    { text: "Hello world", color: "primary" },
    { text: "Hello world", color: "primary" },
    { text: "Hello world", color: "primary" },
    { text: "Hello world", color: "primary" },
    { text: "Hello world" },
    { text: "Hello world", color: "secondary" },
    { text: "Hello world", color: "secondary" },
    { text: "Hello world", color: "secondary" },
    { text: "Hello world", color: "error" },
    { text: "Hello world", color: "error" },
    { text: "Hello world", color: "error" },
    { text: "Hello world", color: "info" },
    { text: "Hello world", color: "info" },
    { text: "Hello world", color: "info" },
    { text: "Hello world", color: "info" },
    { text: "Hello world", color: "neutral" },
    { text: "Hello world", color: "accent" },
  ]}
/>

Above I showed you some steps, they are cool steps

Above I showed you some steps, they are cool steps

## Takeaways & Advice

1. Follow your curiosity.
1. Chase your passions. You might just learn some valuable skills along the way.
1. To learn what's right for you, cast a wide net. Try many things.
1. You're not a failure if your first job isn't at a well-known company. Every company will teach you something new about how to build software. You'll probably only be working there for a few years anyway, on average at least.
1. Learning React is a safe bet. The principles of React have fundamentally changed how we build for the web.
1. It's never too late to change your trajectory. Your career is a marathon, not a sprint.

Also, share your work. Tell people what you're building or learning. It sounds obvious, but learning in public and sharing my findings helped me land multiple jobs in my career.

<Step title="Something new!" no={1} />
<Step title="Something new 2!" no={2} />
<Step title="Something new 3!" no={3} />
<Step title="Something new 4!" no={4} />

Ok, lets try doing and making some code blocks for terminal

```powershell
sudo apt updte
sudo apt upgrade
```

Making some stuff, this is cool. Hello hello world, looking to see.

Ok, lets try doing and making some code blocks for terminal

```shell:terminal
sudo apt updte
sudo apt upgrade
```

Making some stuff, this is cool. Hello hello world, looking to see.

Ok, lets try doing and making some code blocks for terminal

```shell
sudo apt updte
sudo apt upgrade
```

Making some stuff, this is cool. Hello hello world, looking to see.

Ok, lets try doing and making some code blocks for terminal

```
sudo apt updte
sudo apt upgrade
```

Ok, lets try doing and making some code blocks for terminal

```bash
sudo apt updte
sudo apt upgrade
```

Making some stuff, this is cool.

```tsx:/page.tsx {3,4,5,10-14} showLineNumbers
const initialState = { count: 0 };

type ACTIONTYPE =
  | { type: "increment"; payload: number }
  | { type: "decrement"; payload: string };

function reducer(state: typeof initialState, action: ACTIONTYPE) {
  switch (action.type) {
    case "increment":
      return { count: state.count + action.payload };
    case "decrement":
      return { count: state.count - Number(action.payload) };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = React.useReducer(reducer, initialState);
  return (
    <>
      Count: {state.count}
      <button onClick={() => dispatch({ type: "decrement", payload: "5" })}>
        -
      </button>
      <button onClick={() => dispatch({ type: "increment", payload: 5 })}>
        +
      </button>
    </>
  );
}
```

<StaticTweet id="1370213501059231752" />

<StaticTweet id="1370216065108697088" />

<StaticTweet id="1425897481796263938" />

<StaticTweet id="1435190482414432262" />

<StaticTweet id="1476639014341931014" />

<StaticTweet id="1476561758131212289" />

<StaticTweet id="1476639922639433744" />

<StaticTweet id="1475711556109357061" />

<StaticTweet id="1475197920790073358" />

<StaticTweet id="1476701439011475469" />

<StaticTweet id="1476259769409277962" />

<StaticTweet id="1476638703074398210" />

<StaticTweet id="1476708811008217095" />

<StaticTweet id="1476704659704221704" />

<StaticTweet id="1446150424034152449" />

<StaticTweet id="1476969569415794689" />

<StaticTweet id="1477666878562705411" />

<StaticTweet id="1477643552733601794" />

<StaticTweet id="1477662183223963650" />

Hello World, I'm not going to put front-matter in my blog posts

The first piece of starting info. Because we are going to have meany posts. I am going to put separators to separate them. And this mdx text in whole is going; so the next thing I am going to put is link to the original post, and then i'll place separator, and after separator I'm going to put mdx content

First post:

[This is first post](https://leerob.io/blog/mysql-planetscale)

---

A few weeks ago, I [moved this site](https://github.com/leerob/leerob.io/pull/326) from using [Firebase](/blog/real-time-post-views) and [Redis](/blog/serverless-redis-nextjs) to PlanetScale. [PlanetScale](https://planetscale.com) is a serverless database platform built on MySQL and Vitess. Here's why I picked PlanetScale:

- **Database Branching:** I'm able to use my database with the same mental model as git. For each change to my database schema, I open a deploy request. Then, I can merge those changes back into my main database branch.
- **Prisma Support:** In combination with Prisma, it's _so easy_ to handle database migrations. I haven't moved to Prisma (yet) but will soon.
- **Connectionless:** Since PlanetScale is serverless, it's built to withstand thousands of simultaneous connections. You can almost consider this _connectionless_ – the developer doesn't need to worry about [pooling or other common objections](https://twitter.com/leeerob/status/1430177168307412998).
- **Insanely Fast:** After testing 13 databases, PlanetScale was the [fastest to deploy](https://www.youtube.com/watch?v=0zmYHn82cY8). Now, after using it for a few weeks and monitoring performance, I'm seeing APIs resolve in `~150ms` on average (see [results](#results) below).

I had a chance to talk with [Nick from PlanetScale](https://www.youtube.com/watch?v=YqBG5rFP4Ic) on a stream last month if you want to see a live demo of the workflow.

## Why Firebase and Redis?

This site previously used [Firebase](/blog/real-time-post-views) and [Redis](/blog/serverless-redis-nextjs) for real-time blog post views and [my guestbook](/guestbook). The primary decision for choosing these technologies was to learn. I learn best by experimenting and building. I even [created a course](https://react2025.com/) showing how to use Firebase with Next.js, if you're interested.

<StaticTweet id="1434355662935314432" />

Both Firebase and Redis (through [Upstash](https://upstash.com/)) are easy to get started, scale without thinking, and work great in serverless environments. However, I wanted to move to something [SQL-based](/blog/backend) (either MySQL or PostgreSQL) for a new learning experience. I've previously written about [choosing your backend](/blog/backend) and landed on PlanetScale.

## Rebuilding SQL

I found myself writing JavaScript in places where SQL has the functionality built-in. For example, I used Firebase to fetch a JSON object `views` and then summed the values together to find the total number of views.

```jsx
const snapshot = await db.ref("views").once("value");
const views = snapshot.val();
const allViews = Object.values(views).reduce((total, value) => total + value);
```

With SQL, you can use `SUM()` instead. Easier? Yeah. Better? Probably debatable, but I like it.

```sql
SELECT SUM(count) as total
FROM views;
```

Same thing with sorting. Before I was using JavaScript `sort` and now I can use `ORDER BY`. Firebase does have [something similar](https://firebase.google.com/docs/firestore/query-data/order-limit-data), I just wasn't using it.

```sql
SELECT * FROM guestbook
ORDER BY updated_at DESC;
```

## Why MySQL and PlanetScale?

SQL is boring, proven technology. It's been around for years and will continue to be around for years. I've used it before in prior jobs, but still felt I could understand it better. I also enjoy using PostgreSQL (and recommend Supabase) and strongly considered that solution as well. I'm planning to build a different project with Supabase soon.

I'm also a strong believer in using tools I recommend. Without actually getting my hands dirty in code and running an application in production, it's hard to confidently recommend a product to others. After using the [PlanetScale Vercel Integration](https://vercel.com/integrations/planetscale), I was blown away. I could deploy an entire fullstack application in a few clicks. And as I mentioned at the start, database migrations aligned with my mental model.

<StaticTweet id="1426215788407627784" />

## Migrating Existing Data

There are likely better ways to do this, but my hacky solution to migrate data into PlanetScale was as follows:

- Export JSON data from my Firebase Realtime Database

  <Image
    alt={`Exporting data from Firebase`}
    src={`https://res.cloudinary.com/radedev/image/upload/v1640627870/tryout/markus-spiske-c0rsxq6BHN8-unsplash_uokylq.jpg`}
    rounded
  />

- Export JSON data from my Redis cluster using `HVALS` and TablePlus

  <Image
    alt={`Exporting data from my Redis cluster`}
    src={`https://res.cloudinary.com/radedev/image/upload/v1640627870/tryout/possessed-photography-HWhR6lbn5xU-unsplash_zosoyi.jpg`}
    rounded="sm"
  />

- Create a new database branch in PlanetScale for the schema migration adding the tables
- Create two new API routes, which loaded the JSON data and `INSERT INTO` MySQL
- Verify on the database branch the APIs correctly process and migrate the data
- Create a deploy request with the new schema changes and merge it into `main`
- Finally, hit the APIs to migrate the JSON data into `main`
- Done!

Here are the two scripts I used, for reference.

```jsx:pages/api/migrate-redis.js
import db from 'lib/planetscale';
import guestbookData from 'data/guestbook';

export default async function handler(req, res) {
  const toISOString = (unixTimestampInMs) =>
    new Date(unixTimestampInMs).toJSON().slice(0, 19).replace('T', ' ');

  let query = `INSERT INTO guestbook (email, updated_at, body, created_by)
    VALUES `;

  const escapeStr = (str) =>
    str
      .replace(/\\/g, '\\\\')
      .replace(/\$/g, '\\$')
      .replace(/'/g, "\\'")
      .replace(/"/g, '\\"');

  guestbookData.forEach((item, key) => {
    var value = JSON.parse(item['value']);

    query += `("${
      value.email ? `${value.email}` : 'not@provided.com'
    }", "${toISOString(value.updated_at)}", "${escapeStr(value.body)}", "${
      value.created_by
    }")`;

    if (key === guestbookData.length - 1) {
      query += ';';
    } else {
      query += ', ';
    }
  });

  const [rows] = await db.query(query);

  return res.status(201).json(rows[0]);
}
```

```jsx:pages/api/migrate-firebase.js
import db from 'lib/planetscale';
import viewsData from 'data/views';

export default async function handler(req, res) {
  let query = `INSERT INTO views (slug, count)
    VALUES `;

  const slugs = Object.keys(viewsData['views']);

  slugs.forEach((slug, key) => {
    const count = viewsData['views'][slug];

    query += `("${slug}", ${count})`;

    if (key === slugs.length - 1) {
      query += ';';
    } else {
      query += ', ';
    }
  });

  const [rows] = await db.query(query);

  return res.status(201).json(rows[0]);
}
```

Here's my PlanetScale schema for tracking post views and guestbook entries.

```sql
CREATE TABLE `views` (
  `slug` varchar(128) NOT NULL,
  `count` bigint NOT NULL DEFAULT '1',
  PRIMARY KEY (`slug`)
)

CREATE TABLE `guestbook` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `email` varchar(256) NOT NULL,
  `body` varchar(500) NOT NULL,
  `created_by` varchar(256) NOT NULL,
  `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
  `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
  PRIMARY KEY (`id`)
)
```

## Results

I've been monitoring the performance of my production APIs connecting to PlanetScale with [Checkly](https://www.checklyhq.com). Checkly allows me to set alerts if there's downtime or if performance decreases below my accepted threshold. For the last week, I've seen latency of `~150ms` for my Next.js API Routes, deployed as serverless functions on [Vercel](https://vercel.com) in `us-east`.

<Image
  alt={`Checkly results from PlanetScale database`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627869/tryout/jd-x-pj1aVH2tiLE-unsplash_w2cre0.jpg`}
  rounded="md"
/>

This has been significantly faster than my previous Firebase implementation. Can you tell when I made the switch? 😁

<Image
  alt={`Checkly results after switching from Firebase to PlanetScale`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627867/tryout/nikita-kostrykin-vytqXSAi2Ok-unsplash_ruermz.jpg`}
  rounded="lg"
/>

I'm pleased with the results of the migration. Having one service instead of two cleaned up the code and required fewer environment variables to connect to each service. I was also somewhat _abusing_ Redis for my guestbook, where SQL is a better fit.

Next up, Prisma!

---

[This is a second post](https://leerob.io/blog/career)

---

How did I go from a designer to a developer? In this post, I'll share my overnight success story – ten years in the making. First, we have to go way back to 2007.

## Learning Design

I was 14 and found myself fully immersed in the internet. Like many kids, I was an avid gamer. One of my favorites was Halo. I was on their gaming forums chatting with other Halo players. And for those around my age, you might remember something special at the bottom of every post - forum signature banners.

<Image
  alt={`Old forum banners`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627866/tryout/cosmoh-love-unlm6Fxxvjw-unsplash_x0trd2.jpg`}
  priority
  rounded="xl"
/>

These were _so cool_. I thought "I need to have one". Luckily, I happened to grow up in the internet age. YouTube was getting popular and you could find tutorials on anything your heart desired.

So, 14-year-old me managed to follow the _sound_ advice of others online and download a _completely_ legal version of Photoshop (thanks Pirate Bay) to create my own banners. I learned about vectors, brush packs, masking, typography, you name it. And before I knew it, I was actually _pretty good_ at design.

> **Takeaway:** Follow your curiosity.

## Working as a Designer

I continued to use my Photoshop skills mostly for practical jokes, like photoshopping my friends into epic landscapes or other silly things. When I turned 16, I was looking for a summer job and realized I had actually developed _marketable skills_ in the process of following my curiosity. A local t-shirt company was hiring designers to create vector illustrations for sports teams, events, schools, and more. You know, this kind.

<Image
  alt={`Shirt designs`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627865/tryout/hello-i-m-nik-qw3TwCZ_jXg-unsplash_glljgu.jpg`}
  priority
  rounded="2xl"
/>

I applied, and surprisingly, I got hired. That summer, I churned out designs and learned more about Adobe Illustrator than I could have imagined. As high school graduation approached, it seemed natural I would continue with design in college (university). But a looming fear of a career as a designer led me to explore other options.

I was worried about job stability and the intense cirriculum for designers at my college. In retrospect, I didn't have great guidance (easy to say in hindsight). Ultimately, I made the jump for engineering.

> **Takeaway:** Chase your passions. You might just learn some valuable skills along the way.

## Becoming an Engineer

I started college and learned to code in 2011. I chose Computer Engineering because I built my own gaming computer once, and I was the "IT" person for my friends and family. Not exactly a strong foundation to build a career upon.

My first class was _Introduction to Computer Programming_. My professor asked, "How many have had prior programming experience?". More than half the class raised their hands. My hand stayed down. I became nervous.

I struggled throughout my first year of school, scraping by with average grades and low self-esteem. I wanted to quit. "I'm not smart enough to be a programmer", I thought. In hindsight, I was actually just _learning the wrong things for me_.

## What Didn't Work For Me

In our curriculum, students started out by learning the C programming language. For me, C was not the most enjoyable language to work with. I would be fine never having to manually allocate memory ever again. The only part that sparked joy was visualizing command line output.

```c
#include <stdio.h>

int main( int argc, char *argv[] )  {
   if( argc == 2 ) {
      printf("The argument supplied is %s\\n", argv[1]);
   }
   else if( argc > 2 ) {
      printf("Too many arguments supplied.\\n");
   }
   else {
      printf("One argument expected.\\n");
   }
}
```

For example, if I ran the program above and forwarded `hello` on the command line, I'd see `The argument supplied is hello`. Incredible! While I dreaded almost everything about C, it did start teaching me the fundamentals of programming: variables, loops, functions, and more.

Next, we learned Java. This was a big improvement over C for me. No more [manual memory management](<https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)>)! And even more visual applications: [Java Swing](<https://en.wikipedia.org/wiki/Swing_(Java)>). Now we're talking!

<Image
  alt={`Java Swing program`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627865/tryout/nassim-allia-qmg9NR8RkAk-unsplash_qklzy7.jpg`}
  rounded="3xl"
/>

The next semester we learned web development. This is where the pieces began to fall into place for me. The visual aspect of the web felt like the missing link between design and development. The web felt like a place I could experiment, build, and most importantly **share with anyone**.

> **Takeaway:** To learn what's right for you, cast a wide net. Try many things.

## Humble Beginnings

Even though I was excited about the web, building web apps in 2012 wasn't as beginner-friendly as it is today. I learned HTML, CSS, JavaScript, jQuery, and even that [Bootstrap](<https://en.wikipedia.org/wiki/Bootstrap_(front-end_framework)>) library. Simple websites made sense, but then I was exposed to the world of back-end development... what in the world is a LAMP stack!? [Impostor syndrome](https://en.wikipedia.org/wiki/Impostor_syndrome) reared its ugly head again.

<Image
  alt={`LAMP stack`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627863/tryout/lorenzo-herrera-p0j-mE6mGo4-unsplash_qbnhxs.jpg`}
  rounded="full"
/>

Nevertheless, I passed my web development classes with higher marks and ended up landing an internship. It wasn't exactly what I wanted -- I was writing automated tests. But I got my foot in the door. I started to learn what a career as a Software Engineer looked like.

One internship led to two, and then three, and finally a full-time job after graduating [with honors](https://en.wiktionary.org/wiki/cum_laude). Quite a turnaround from wanting to drop out and quit programming just a few years prior. My determination and perseverance paid off.

> **Takeaway:** You're not a failure if your first job isn't at a well-known company. Every company will teach you something new about how to build software.

## Exponential Growth

<StaticTweet id="826528907381739520" />

While I enjoyed web development, the front-end never _fully clicked_ for me until I started using React a few years later in my first full-time job. Up until this point, most "modern web development" at the time seemed so complex. Learning React, and then starting to use Create React App, helped me finally break free from JavaScript build tool hell and focus on building great websites. This is when I started to grow exponentially as a developer.

Specializing on one specific thing (React) led to a snowball effect. Suddenly, I was becoming proficient in other related skills. Understanding the fundamentals led to faster adoption of the next layer of tools, and finally to understanding and creating my own backends and APIs.

> **Takeaway:** Learning React is a safe bet. The principles of React have fundamentally changed how we build for the web.

## The Present

I've now been working with React since 2015. Since then I've largely been a product engineer, working in financial tech and e-commerce. About three years ago, I realized I wanted to make a shift in my career.

I wanted to create. I wanted to write, record, stream, post, tweet, and grow a community. I wanted to help others learn and progress in their careers as developers. After teaching over 100,000 developers from around the world with courses and tutorials, I joined the team at Vercel and now lead [Developer Relations](https://leerob.io/blog/head-of-devrel).

> **Takeaway:** It's never too late to change your trajectory. Your career is a marathon, not a sprint.

## Takeaways & Advice

1. Follow your curiosity.
1. Chase your passions. You might just learn some valuable skills along the way.
1. To learn what's right for you, cast a wide net. Try many things.
1. You're not a failure if your first job isn't at a well-known company. Every company will teach you something new about how to build software. You'll probably only be working there for a few years anyway, on average at least.
1. Learning React is a safe bet. The principles of React have fundamentally changed how we build for the web.
1. It's never too late to change your trajectory. Your career is a marathon, not a sprint.

Also, share your work. Tell people what you're building or learning. It sounds obvious, but learning in public and sharing my findings helped me land multiple jobs in my career.

<StaticTweet id="1334334544598740994" />

- A good boot camp is better than an average degree (for programming).
- You don't need formal education, but if you forego traditional structure and community, you must recreate it yourself.
- Create an [online presence](/blog/beginners-guide-to-the-programming-portfolio#why-do-you-need-a-portfolio). Showcase your work. [Write](/blog/teach-online#writing-online). Share what you've learned. Attract other like-minded people. Create serendipity.

The best time to start was yesterday. The second best time is today.

---

[This is a third post](https://leerob.io/blog/serverless-redis-nextjs)

---

When front-end developers are learning the full-stack, they often stumble on which [backend to use](/blog/backend). If they hear Redis, they think of in-memory caching. That's what I thought, at least.
After doing more research, I was surprised to find Redis excels at [hashmaps, counters, sorted lists, and even queues](http://oldblog.antirez.com/post/take-advantage-of-redis-adding-it-to-your-stack.html). It's possible to use Redis for your entire database!

This article will explore using Redis with Next.js in Serverless environments.

### Creating a Redis Instance

[Upstash](https://upstash.com/) is the easiest way I've found to deploy a managed Redis instance. A few reasons I recommend it:

- There's a generous free tier, and then per-request pricing when you're ready to upgrade. This keeps costs free (or extremely low). There's even a $120/month cap to prevent surprises, plus reserved plans for larger projects.
- With Upstash, you can use Redis for more than just caching with durable storage. There's even [Strong Consistency](https://docs.upstash.com/docs/overall/consistency) mode for guaranteed, durable writes.
- It's fast. Really, really fast. Extremely low latency.

The Upstash Integration for Vercel makes it easy to get started with Serverless Redis. We'll start by deploying the [completed project](https://roadmap-redis.vercel.app/), and then running the application locally.

1. [Deploy the demo to Vercel using the Upstash Integration.](https://vercel.com/new/git/external?repository-url=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-redis&project-name=redis-roadmap&repository-name=redis-roadmap&demo-title=Redis%20Roadmap&demo-description=Create%20and%20upvote%20features%20for%20your%20product.&demo-url=https%3A%2F%2Froadmap-redis.vercel.app%2F&integration-ids=oac_V3R1GIpkoJorr6fqyiwdhl17)
2. You'll be prompted to sign-up or sign-in to Upstash.
3. Then, you can create a free database and attach it to your Vercel project.
4. Click "Complete on Vercel".
5. That's it! You should have a deployed project and URL.

By default, both Vercel and Upstash use the `us-east-1` region for Serverless Functions. Using the same region is critical to minimize latency between your [Serverless Functions](https://vercel.com/docs/serverless-functions/introduction) and Redis.

### Connecting to Redis

If you're using Vercel, you can clone the git repository created during deployment.
The `REDIS_URL` environment variable was added by the Upstash Integration while deploying. To run the application locally, we'll need to pull our environment variables locally using the [Vercel CLI](https://vercel.com/download).

```jsx
$ vercel link
$ vercel env pull .env.local
```

If you're not using Vercel, you can clone this demo locally using `npx create-next-app --example with-redis roadmap`.
Then, create an `.env.local` file in the root of your repository and add the Redis connection string.

```jsx:.env.local
REDIS_URL=redis://:password@endpoint:port
```

We'll use [ioredis](https://github.com/luin/ioredis), a Node.js Redis client with [async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) support, to connect to Redis.

```jsx:lib/redis.js
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

export default redis;
```

Finally, we can use this inside any page or API Route to retrieve information from Redis.

```jsx
import redis from "lib/redis";

const value = JSON.parse(await redis.hget("feedback", id));
```

### Using Redis with Next.js

Here's a few common Redis commands you might need to use:

- Fetching a JSON object: `redis.hget('feedback', id)`
- Creating a JSON object: `redis.hset('feedback', id, "{'key': 'val'}")`
- Deleting by key: `redis.hdel('feedback', id)`
- Fetching a list of items: `redis.hvals('feedback')`

In the demo application, we use Redis for the following:

1. The feature list is server-rendered using `getServerSideProps`. We fetch all features and sort based on the score and title.
1. The initial feature list from the server populates the local cache of [SWR](swr.vercel.app). This ensures data remains up-to-date on the client-side.
1. When adding features or emails, a `POST` request is sent to an [API Route](https://nextjs.org/docs/api-routes/introduction) to update Redis.
1. Adding/upvoting features will mutate the client-side cache for [optimistic UI updates](https://swr.vercel.app/docs/mutation).

You can view the entire Redis API [here](https://redis.io/commands). For more advanced Redis usage, see the Redis API compatibility with Upstash [here](https://docs.upstash.com/docs/overall/rediscompatibility/).

### Conclusion

I frequently need to store data, somewhere. It doesn't always need to be complex – a key/value store will often suffice.
After working more with Upstash, Redis is now my preferred solution for this (and apparently [many other people's as well](https://www.freecodecamp.org/news/stack-overflow-developer-survey-2020-programming-language-framework-salary-data/)).

- [View the demo ✨](https://roadmap-redis.vercel.app/)
- [Deploy your own 🚀](https://vercel.com/new/git/external?repository-url=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-redis&project-name=redis-roadmap&repository-name=redis-roadmap&demo-title=Redis%20Roadmap&demo-description=Create%20and%20upvote%20features%20for%20your%20product.&demo-url=https%3A%2F%2Froadmap-redis.vercel.app%2F&integration-ids=oac_V3R1GIpkoJorr6fqyiwdhl17)

**Bonus:** If you need to inspect your Redis database locally, check out [TablePlus](https://tableplus.com/) for a GUI and [redis-cli](https://docs.upstash.com/docs/overall/getstarted#connect-to-your-database) if you prefer the command-line.

---

[This is a fourth post](https://leerob.io/blog/react-state-management)

---

React was introduced in May 2013. Its paradigm shift was that **your UI was a function of your state**. Given some component state, React can determine what your component will look like. React is _built_ upon the idea of state. However, state has long been one of the most difficult parts of building a React application.

Let's imagine state management in React as a rugged tool belt. You've used this tool belt for years, slowly adding new tools as needed. Each tool serves a very specific purpose. You don't use your hammer to screw in bolts. As a craftsman, you've learned the right time and place to use each tool.

**State management with React is a rugged tool belt, but not everyone has the prior experience to know which tool to reach for.** This post will explain the past, present, and future of state management to help you make the correct decision for your team, project, or organization.

## Glossary

Before we begin, it's critical you understand some of the terms commonly used. These aren't the canonical names. A few different variations of each float around, but the underlying ideas are the same:

- UI State – State used for controlling interactive parts of our application (e.g. dark mode toggle, modals).
- Server Cache State – State from the server, which we cache on the client-side for quick access (e.g. call an API, store the result, use it in multiple places).
- Form State – The many different states of a form (e.g. loading, submitting, disabled, validation, retrying). There's also [controlled & uncontrolled form state](https://reactjs.org/docs/forms.html).
- URL State – State managed by the browser (e.g. filter products, saving to query parameters, and refreshing the page to see the same products filtered)
- State Machine – An explicit model of your state over time (e.g. a stoplight goes from green → yellow → red, but never green → red).

## Past

React's component model helped create reusable, composable applications. Each component had its own local state. As web apps became more complex, new solutions emerged to more easily share logic between components.

### Timeline

To help you understand how state management has evolved over time, here's a rough timeline of popular state management solutions in React. This list is heavily focused on UI State. This list is not comprehensive, but is enough to give context.

- 2013 – Introduction
- 2014 – Flux (many libraries)
- 2015 – Redux
- 2016 – MobX
- 2018 – Context
- 2019 – Hooks Introduced (+ React Query, SWR)
- 2019 – Zustand
- 2019 – xState
- 2020 – Jotai, Recoil, Valtio
- 2021 – useSelectedContext

Just because an item is listed on this timeline does not mean you need to learn it. More on this later. Let's dive into the history of state management in React.

### Redux

[Redux](https://redux-toolkit.js.org/) was originally created as an implementation of the "[Flux Architecture](https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/#redux-was-built-as-a-flux-architecture-implementation)", which was a pattern first suggested by Facebook in 2014. Redux came out in 2015 and quickly became the most popular of many Flux-inspired libraries. It's ecosystem of tools and libraries encapsulated both UI state and server caching state. **Redux is still extremely popular and widely used.**

<Image
  alt={`Redux Growth`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627826/tryout/something_u0fosj.jpg`}
/>

### Server Caching State

In the early days of React, lots of state management boiled down to fetching data from APIs and caching it for use across the application. The community leaned heavily on libraries like Redux because there wasn't an easy, widely used way to manage _just_ the server cache state.

With the release of [React Hooks](https://reactjs.org/blog/2019/02/06/react-v16.8.0.html), encapsulating logic into shared hooks became much easier and accessible. Libraries like [SWR](https://swr.vercel.app/) and [React Query](https://react-query.tanstack.com/) emerged to solve this problem specifically.

You might think "Why have a separate library just for server caching state?". Well, **caching is hard**. Server caching state solves different problems than UI state. Here's a shortlist of some of the things these libraries handle for you:

- Polling on interval
- Revalidation on focus
- Revalidation on network recovery
- Local mutation (Optimistic UI)
- Smart error retrying
- Pagination and scroll position recovery

Do you want to implement those yourself? _Probably not._

### React Context

With [v16.3](https://reactjs.org/blog/2018/03/29/react-v-16-3.html), React Context gave us a first-party solution to share logic between components. This also prevented passing values down as props through multiple levels of nested components (i.e. "[prop-drilling](https://kentcdodds.com/blog/prop-drilling)").

React Context itself is [not state management](https://blog.isquaredsoftware.com/2021/01/context-redux-differences/). It can, however, [be paired with hooks](https://kentcdodds.com/blog/application-state-management-with-react) like `useReducer` to become a state management solution. This combination solved UI state for many common use cases.

<Image
  alt={`React Context`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627826/tryout/dolleth_b3jm2w.jpg`}
  rounded="full"
/>

## Present

In 2021, there are various ways to handle state management in React. As the community has grown to understand the different types of state, more granular libraries have been created solving very specific use cases.

### State Machines

Let's consider a switch statement. If the value of `state` matches any `case`, the corresponding code runs. There's a finite set of cases. This is the most simple state machine – an explicit model of your state.

```jsx
switch (state) {
  case state === "loading":
    // show loading spinner
    break;
  case state === "success":
    // show success message
    break;
  default:
  // show error message
}
```

[Finite State Machines](https://xstate.js.org/docs/about/concepts.html#finite-state-machines) and [Statecharts](https://xstate.js.org/docs/about/concepts.html#statecharts) are fundamental Computer Science concepts, so this isn't anything React specific. You can turn [`useReducer`](https://reactjs.org/docs/hooks-reference.html#usereducer) into a state machine without any third-party libraries.

State Machines are well-adopted everywhere, including databases, electronics, cars, and more. As state management evolved in the React ecosystem, we realized these old ideas could solve modern state management issues. State Machines are most prevalent for solving form state.

With a Finite State Machine, you have a finite number of states your application or component could be in. In practice, State Machines help you uncover bugs as you're required to think through and define edge cases. For much more information on this, I'd recommend checking out the [xState](https://xstate.js.org/docs/) docs or watching [this course](https://egghead.io/courses/introduction-to-state-machines-using-xstate). You can also [visualize entire state machines online](https://xstate.js.org/viz/).

<Image
  alt={`State Machines`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627826/tryout/lap2_mwqiaq.jpg`}
  rounded="3xl"
/>

### Zustand, Recoil, Jotai, Valtio, Oh My!

Why do so many different libraries for React state management even exist?

Let's consider Figma (or any other design tool). You have a toolbar of controls that affect other elements outside of its "local" state, or where the component is rendered.

<Image
  alt={`Figma`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627824/tryout/coins_ioilhr.jpg`}
  rounded="sm"
/>

As you can imagine, an application of this scale would require a complex state management solution. Performance and frame rate are critical for a good user experience here, so you want control over when & how to re-render. Unique use cases like this have led to lots of exploration in the state management space.

To summarize the differences between these libraries, let's hear from [Daishi Kato](https://twitter.com/dai_shi/status/1348257768130560008):

- **Valtio** uses proxies to provide a mutation-style API
- **Jotai** is optimized for "computed values" and async actions
- **Zustand** is a very thin library specifically focused on module state
- **Recoil** is an experimental library using a data-flow graph

Having complex state doesn't necessarily mean you _have_ to pull for a third-party library. You can start with React and JavaScript and see how far it takes you. If optimizing requires a state management library, you can track that metric (e.g. frame rate), measure it, and verify it solves a real problem.

**Don't choose one of these libraries unless there's an obvious need.**

### Immutable State

Another debate is mutable vs. immutable state. There's no right answers, just opinions. If you were doing state management with vanilla JavaScript, you'll likely have mutable state. You initialize a variable, and then later set it equal to some new value. There are [entire debates](https://overreacted.io/on-let-vs-const/) on `let` vs. `const`.

Immutable state gained a lot of popularity with React. The immutable crowd argues that allowing your state management solution of choice to mutate state directly results in more bugs. The mutable crowd argues it's not worth the complexity trade-off. Direct manipulation will always be less safe than indirect manipulation. It's a tradeoff between convenience and risk, which is up to you and your team.

Solutions like [Immer](https://immerjs.github.io/immer/) allow you to write mutable code but _execute_ it immutably. Fancy. The basic idea is you apply your changes to a _draft state_, which is a proxy of the _current state_. Once the mutations have completed Immer will produce the _next state_ based on the changes to the draft state.

<Image
  alt={`Immer Immutable State`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627823/tryout/keyboard_o06g5e.jpg`}
  rounded
/>

### URL State

Let's say you're building an e-commerce website like Amazon. You search for React books and filter by 4+ stars. This state is persisted as query parameters and managed by the browser. When you refresh the page, you see the same list of products. You can share this URL with others and they also see the same results.

<Image
  alt={`Amazon URL State`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627823/tryout/rust-hero_rufduj.jpg`}
  rounded="3xl"
/>

Another interesting example of this is Nomad List. We can transform the browser URL state into a function of our data. Plus, we can make human-readable URLs (which Google prefers).

<Image
  alt={`Nomad List URL State`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627823/tryout/bitcoin_kbn4xj.jpg`}
  rounded="3xl"
/>

### Future

For large applications, it's possible a naive Context-based state management solutions (e.g. with `useReducer`) could have issues with excessive re-rendering. When a context value changes, all components that `useContext` will re-render. This makes UI interactions feel slow and janky. If you can't visually notice it, you can [use React Dev Tools](https://brycedooley.com/debug-react-rerenders/) to investigate re-rendering.

The React team has proposed a `useSelectedContext` hook to prevent performance issues with Context at scale. This [RFC was introduced](https://github.com/reactjs/rfcs/pull/119) in July 2019 and [progress has started](https://github.com/facebook/react/pull/20646) as of January 2021 behind a feature flag. This hook allows you to select a "slice" of Context and only re-render when that piece changes.

There are ways to work around re-rendering performance already (e.g. `useMemo`) but a first-party solution for Context is preferred. There's also a community library [useContextSelector](https://github.com/dai-shi/use-context-selector), which takes a similar approach ([demo](https://codesandbox.io/s/usecontextselector-demo-sixdr?file=/src/App.js)). [Jotai](https://github.com/pmndrs/jotai) and [Formik 3](https://formik.org/blog/formik-3-alpha) use this under the hood. Having `useSelectedContext` as part of the React standard library will eliminate complexity and code size in external libraries, as well as provide more performant options by default.

In the longer-term future, React will automatically figure out which components to re-render ("[auto-memoization](https://github.com/reactjs/rfcs/pull/119#issuecomment-586390430)").

## State Management Options

This is not a comprehensive list. It's also open-source, so please open a PR if you disagree or if something is wrong. In general, lean on whatever empowers your developers and team. **Happy with Redux? Stay there!**

### Form State

| Experience   | Learning Appetite | Project/Team Size | Solution                          |
| ------------ | ----------------- | ----------------- | --------------------------------- |
| Beginner     | Low               | Small             | useState                          |
| Beginner     | Medium            | Medium, Small     | Form Library (Formik, Final Form) |
| Beginner     | High, Medium      | Large             | Ask your tech lead                |
| Intermediate | Low               | Medium, Small     | Form Library (Formik, Final Form) |
| Advanced     | Medium            | Medium            | State Machines                    |
| Advanced     | High              | Medium            | State Machines                    |
| Advanced     | High              | Large             | State Machines                    |

### UI State

| Experience   | Learning Appetite | Project/Team Size | Solution                             |
| ------------ | ----------------- | ----------------- | ------------------------------------ |
| Beginner     | Low               | Small             | useState                             |
| Beginner     | Medium            | Medium, Small     | useContext + useReducer              |
| Beginner     | High, Medium      | Large             | Ask your tech lead                   |
| Intermediate | Low               | Medium, Small     | Redux Toolkit                        |
| Advanced     | Medium            | Medium            | useContext + useReducer              |
| Advanced     | High              | Medium            | Jotai, Valtio                        |
| Advanced     | High              | Large             | Recoil (or Relay if you use GraphQL) |

### Server Cache State

Regardless of experience or team size, both [SWR](https://swr.vercel.app/) and [React Query](https://react-query.tanstack.com/) are excellent solutions. You'll be happy with either. If you're using GraphQL, you probably already know about [Apollo](https://www.apollographql.com/).

### That's all, folks!

State management in React has evolved massively over the past eight years. It's one of the most difficult, nuanced parts of building large web applications. Understanding the different types of state and their trade-offs is crucial for making an informed decision. I hope this post has helped – thanks for reading.

---

[This is fifth post](https://leerob.io/blog/fonts)

---

Typography accounts for [95% of web design](https://ia.net/topics/the-web-is-all-about-typography-period/). Your font choice can be critical for branding, readability, and performance.

[Over time](https://thehistoryoftheweb.com/web-fonts/), recommendations for using web fonts have changed as browsers adopted new standards. Now in 2021, I wanted to learn the best practices for using web fonts on high-performance sites.

## System Fonts

The fastest way to use a web font is none. Browsers include a set of [web-safe fonts](https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Fundamentals#Web_safe_fonts) (e.g. Arial, Georgia, Times New Roman) you can use by default.

Using web-safe fonts or the [system font stack](https://systemfontstack.com/) will be the fastest option.

```css
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial,
  sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
```

## Why Use Web Fonts?

If system fonts are the fastest option, why do web fonts exist? Branding, improved design, and cross browser and device consistency. [82% of web pages for desktop](https://almanac.httparchive.org/en/2020/fonts) use web fonts.

Let's cover five different areas for high-performance web fonts and conclude with a 2021 recommendation.

- Self Hosting
- Preloading
- Font Display
- Variable Fonts
- Subsetting

## Self Hosting

[Google Fonts](https://fonts.google.com/) is responsible for [70% of all web font usage](https://almanac.httparchive.org/en/2020/fonts#serving-with-a-service). With over 1000 fonts, they provide easy access to quality fonts, multiple formats, and performant defaults (pre-connecting and swapping).

However, **Google Fonts is no longer necessary**. Since 2018, [Google has advised self-hosting](https://developers.google.com/web/updates/2018/08/web-performance-made-easy) for optimal performance through preloading.

There aren't any caching advantages anymore, either. Let's say you're using the font "Roboto", which is [a popular font](https://fonts.google.com/?sort=popularity) on Google Fonts. Chances are you've visited another site using "Roboto" and cached the font.

Since October 2020, Chrome [no longer allows](https://developers.google.com/web/updates/2020/10/http-cache-partitioning) a shared cache across sites. Safari has worked this way since 2013. "Roboto" will be re-downloaded for every site, regardless of it being cached.

When self-hosting, ensure you cache your font with the `Cache-Control` HTTP header. `immutable` tells the browser the file will never change. When a request is made within the `max-age` (1 year), it avoids the roundtrip to ensure it's the latest content.

```bash
Cache-Control: public, immutable, max-age=31536000
```

If you need Google Fonts, [use these optimizations](https://csswizardry.com/2020/05/the-fastest-google-fonts/). With the latest changes in the v2 API, you can tailor fonts to specific users and platforms (including variable fonts).

## Preloading

The browser assigns [loading priorities](https://web.dev/prioritize-resources/) to different types of resources. By default, CSS will be loaded before scripts and images. You can influence the importance of resources by [preloading critical assets](https://web.dev/preload-critical-assets/).

Fonts are discovered late by the browser by default. By preloading, we fetch the font file as soon as possible. Then, the browser caches the font making it available immediately.

Preloading can improve performance metrics like [Time to Interactive](https://web.dev/interactive) and [First Contentful Paint](https://web.dev/first-contentful-paint). For example, Shopify saw a [50% (1.2 second) improvement](https://twitter.com/ShopifyEng/status/844245243948163072) in First Contentful Paint, removing their Flash of Invisible Text (FOIT).

As of 2020, [75% of web fonts use WOFF2](https://almanac.httparchive.org/en/2019/fonts). You likely only need this. For example:

```css
<link
	rel="preload"
	href="/fonts/inter-var-latin.woff2"
	as="font"
	type="font/woff2"
	crossOrigin="anonymous"
/>
```

> Support: All modern browsers except Firefox.

## Font Display

`font-display` allows you to modify the rendering behavior of web fonts with values such as `auto`, `swap`, `block`, `fallback` and `optional`. When loading web fonts, we want to prevent [layout shift](https://web.dev/cls/). This occurs in two ways:

- Flash of Unstyled Text (FOUT) — The fallback font is swapped with a new font (e.g. `swap`).
- Flash of Invisible Text (FOIT) — Invisible text is shown on the page until a new font is rendered (e.g. `block`).

Browsers currently have a default strategy similar to `block`. The only option that eliminates layout shift is `optional`. Combined with the other performance optimizations in this article, `optional` is your best choice.

```css
@font-face {
  font-family: "Inter";
  font-style: normal;
  font-display: optional;
  src: url(/fonts/inter-var-latin.woff2) format("woff2");
}
```

> Support: All modern browsers

## Variable Fonts

[Variable fonts](https://web.dev/variable-fonts/) allow us to combine multiple styles and weights (e.g. bold, italic) into a single font file.

```css
@font-face {
  font-family: "Inter";
  font-style: normal;
  font-weight: 100 900; // Range of weights supported
  font-display: optional;
  src: url(/fonts/inter-var-latin.woff2) format("woff2");
}
```

You can try out different variable font options [here](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fonts/Variable_Fonts_Guide).

> Support: All modern browsers. Even Google Fonts v2 API has support for variable fonts.

## Subsettings

Font files contain multiple languages and glyphs, which increase the file size. Subsetting is the removal of characters you don’t need.

For example, we might use the Inter variable font and subset to latin languages.

```css
@font-face {
  font-family: "Inter";
  font-style: normal;
  font-weight: 100 900; // Range of weights supported
  font-display: optional;
  src: url(/fonts/inter-var-latin.woff2) format("woff2");
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA,
    U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215,
    U+FEFF, U+FFFD;
}
```

## Conclusion

1. Use a variable font
2. Preload your font file
3. Self-host instead of Google Fonts
4. Use `font-display: optional` to prevent layout shift

[Here's an example](https://github.com/leerob/leerob.io) of a site implementing all these recommendations.

## Future

If you need to use `font-display: swap`, future support for [Font Metrics Override](https://www.youtube.com/watch?t=176&v=Z6wjUOSh9Tk&feature=youtu.be) will reduce layout shift when swapping.

```css
@font-face {
  font-family: ...;
  src: ...;
  ascent-override: 80%;
  descent-override: 20%;
  line-gap-override: 0%;
  ...;
}
```

---

[This is sixt post](https://leerob.io/blog/tailwind)

---

My site is an opportunity to try new tech and form opinions on what I enjoy using. I learn best by building real things. After some evaluation, I've landed on the following tech stack:

- Next.js (Upgraded to `v10`)
- Tailwind CSS (Switched from Chakra UI)
- `next-mdx-remote` (Switched from `next-mdx-enhanced`)
- Deployed with Vercel

I've improved performance, added new features, and cleaned up some code. Let's dive into why I chose this tech stack.

### Next.js 10

Next.js 10 introduced the [Image Component and Automatic Image Optimization](https://nextjs.org/docs/basic-features/image-optimization). I've optimized images manually before (using ImageAlpha / ImageOptim) as well as with automated tools (like ImgBot). With Next.js 10, I no longer need to worry about that.

The `Image` component helps prevent [Cumulative Layout Shift](https://web.dev/cls/) (CLS) by defining the `width` and `height` ahead of time. No more jumping layouts. It only loads images as they're scrolled into the viewport, keeping page loads fast. Plus, images are served in modern formats like [WebP](https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Image_types) when the browser supports it.

Preventing CLS required a mental model shift. Previously, my images used normal Markdown image syntax and expanded to fill the width of their container (`700px`). For example:

```jsx
![Siamese Cat](/cat.png)
```

I wanted to avoid using the `height` and `width` props of `next/image`, if possible. The `Image` component exposes different [layout props](https://nextjs.org/docs/api-reference/next/image#layout) like `layout=fill`, which led to me believe I could [escape defining sizes](https://github.com/vercel/next.js/blob/canary/examples/image-component/pages/layout-fill.js). In reality, there's no way to avoid layout shift unless you explicitly tell the layout how much space to allocate. Once that clicked in my head, the `Image` component made sense.

This meant switching from Markdown image syntax (shown above) to using `next/image` via MDX. Since I had hundreds of Markdown files, I wanted to automate this. I created a [Node script using remark](https://github.com/leerob/leerob.io/blob/fb9c02b76128d91717a226e5c118b5c56e11696e/scripts/markdown-to-next-image.js) that transformed every image and read the dimensions from the file system. For example, the above Markdown image was transformed to:

```jsx
<Image alt="Siamese Cat" src="/images/shibonk.svg" rounded="full" />
```

### Tailwind CSS

At first glance, Tailwind seems horrible. I've heard this sentiment many times and read [Adam's rebuttals](https://adamwathan.me/css-utility-classes-and-separation-of-concerns/). Earlier this year, I had the opportunity to try Tailwind on a project. I didn't hate it. Still, I needed a larger project to form an opinion on the framework.

Well, the verdict is out. **I really enjoy Tailwind.** There was a learning curve as I tried to translate my existing CSS knowledge to Tailwind specific naming. For example, this vanilla CSS:

```css
display: flex;
flex-direction: row;
align-items: center;
```

translates to these utility classes with Tailwind:

```jsx
<div className="flex flex-row items-center" />
```

The Tailwind classes feel intuitive and their documentation makes it easy. The underlying idea of being bound to a design system made plenty of sense coming from Chakra UI. For example:

```jsx
import { Flex } from "@chakra-ui/react";

<Flex px={4} py={2} />;
```

Chakra's [spacing system](https://chakra-ui.com/docs/theming/theme#spacing) is inspired by Tailwind. 1 spacing unit is equal to `0.25rem`, which translates to `4px` by default in most browsers. In the example below, we're adding `16px` of horizontal padding and `8px` of vertical padding.

```jsx
<div className="px-4 py-2" />
```

I still enjoy Chakra for larger applications. Having pre-built UI components saves a lot of time. Their documentation has some good notes on the [differences between Tailwind](https://chakra-ui.com/docs/comparison#how-is-chakra-different-from-tailwind-css). For further reading, check out [How Should I Style My React Application?](/blog/css-with-react).

### Dark Mode

Tailwind 2.0 makes using dark mode painless. Enable the `dark` [variant](https://tailwindcss.com/docs/dark-mode) and prefix your classes with `dark:`. That's pretty much it.

```jsx
<div class="bg-white dark:bg-gray-800" />
```

I was able to keep a [dark mode toggle](https://github.com/leerob/leerob.io/blob/91233631f0e1a193295ffc54d2291f3109060007/components/Container.tsx) in the navigation thanks to [next-themes](https://github.com/pacocoursey/next-themes). Tailwind and `next-themes` [pair well](https://github.com/pacocoursey/next-themes#with-tailwind) together.

```jsx
import { useTheme } from "next-themes";

const ThemeChanger = () => {
  const { theme, setTheme } = useTheme();

  return (
    <div>
      The current theme is: {theme}
      <button onClick={() => setTheme("light")}>Light Mode</button>
      <button onClick={() => setTheme("dark")}>Dark Mode</button>
    </div>
  );
};
```

I hit a few issues along the way adding dark mode to Tailwind Typography. The documentation felt a bit disjointed from the rest of Tailwind. I would have expected more guidance on pairing the two together.

After digging through GitHub Issues, I was able to [get things working](https://github.com/leerob/leerob.io/blob/91233631f0e1a193295ffc54d2291f3109060007/tailwind.config.js). It wasn't obvious I needed `dark:prose-dark`. I also managed to get [syntax highlighting](https://github.com/leerob/leerob.io/blob/91233631f0e1a193295ffc54d2291f3109060007/styles/global.css) working through some custom styles.

## Performance

Libraries like `emotion` and `styled-system` require runtime JavaScript to compute styles and generate class names. That doesn't mean you can't use [CSS-in-JS](https://github.com/callstack/linaria) [correctly](https://github.com/ben-rogerson/twin.macro). But I'd argue using "plain" CSS helps you fall into the [pit of success](https://blog.codinghorror.com/falling-into-the-pit-of-success/) ([CSS Modules](https://nextjs.org/docs/basic-features/built-in-css-support), Tailwind, etc) more easily.

There is no correct answer. Each has their own tradeoffs. For my simple site, I choose the performance tradeoff. I was able to reduce the [number of assets downloaded](https://nextjs.org/docs/api-reference/cli#build) **by 43%**.

- 📦 Before → `~150kb` First Load JS
- 📈 After → `~85kb` First Load JS

This change, paired with `next/image`, has my [Vercel Analytics](https://vercel.com/docs/analytics) looking incredible. Zero CLS.

<Image
  alt={`Vercel Analytics`}
  src={`https://res.cloudinary.com/radedev/image/upload/v1640627822/tryout/code_tkdxsv.jpg`}
  rounded="2xl"
/>

I'm also evaluating using Preact in the [client-side production build](https://github.com/leerob/leerob.io/commit/74a3ebb14b81f785ea96f9c73fbe4f6c2463679c). This prevents needing [next-plugin-preact](https://github.com/preactjs/next-plugin-preact) to handle SSR and HMR ([source](https://blogify.dev/egoist/how-i-made-my-next-js-build-50-percent-smaller)). So far, I haven't noticed any issues with my small site and the results are promising. **39% smaller**.

- 📦 Before → `~85kb` First Load JS
- 📈 After → `~52kb` First Load JS

### MDX

[Last year](/blog/mdx), I switched from using `@next/mdx` to `next-mdx-enhanced` mostly for front matter and layout support. These are now both [solved problems](https://nextjs.org/blog/markdown). Given that [next-mdx-enhanced](https://github.com/hashicorp/next-mdx-enhanced) will likely be deprecated soon (see below) I wanted to explore [next-mdx-remote](https://github.com/hashicorp/next-mdx-remote).

> You probably should be using `next-mdx-remote` instead of this library. It is ~50% faster, more flexible with content storage, does not induce memory issues at scale, and fits much better with the way that data is intended to flow through Next.js.

With the addition of `getStaticPaths` / `getServerSideProps`, you can treat your MDX data like any other data source in Next.js. It also removes the limitation of being bound to [file-system based routing](https://nextjs.org/docs/basic-features/pages) for your `.mdx` files. Since my site has hundreds of MDX files, moving these to a top-level `data/` folder made more sense to me.

Still, the MDX experience feels _fragmented_. I'd like to merge `next-mdx-remote` with `@next/mdx` so there are fewer options. [nextra](https://github.com/shuding/nextra) (another related project) allows you to use methods like `getStaticProps` directly inside your MDX files. Maybe there's a path to convergence for all three.

### Other

I added [absolute Imports and module path aliases](https://nextjs.org/docs/advanced-features/module-path-aliases) to improve the readability of nested imports inside files. Here's a before and after example:

```jsx
// Before
import db from "../../lib/db-admin";

// After
import db from "lib/db-admin";
```

I also merged my previous project (jamstackfns) directly into this site with a new section called [Snippets](/snippets)! These are interesting pieces of code that didn't justify writing an entire blog post. For example, here's a few snippets I've added recently:

- [React hook for storing a search value with Context](/snippets/search)
- [React hook for displaying loading progress](/snippets/loading-progress)
- [React hook to parse an email from a URL](/snippets/email-query-params)
- [Gradient border with CSS](/snippets/gradient-border)
- [Sticky navigation with CSS](/snippets/sticky-nav)
- [CRUD Next.js API route](/snippets/crud-api-route)

---

[This is seventh post](https://leerob.io/blog/css-with-react)

---

React attempts to be as unopinionated as possible. This is both it's greatest strength _and_ weakness.

Over the years, I've tried many different ways to style my React apps. Each solution has its pros and cons.
This article will share my journey using CSS with React and how it's evolved to its current state. Then, I'll discuss pros/cons of
different approaches for styling.

## Vanilla CSS

Like most, I started web development with vanilla CSS. All you need is a single HTML and CSS file. Pretty simple.

```html:index.html
<h1 class="header">Welcome</h1>
```

```css:index.css
.header {
  font-size: 32px;
}
```

As I built more large applications, I began to understand some of the drawbacks.

- **Reusability.** It's easy to create append-only stylesheets that become very complex.
- **Global Namespace.** Since CSS has a [global namespace](https://css-tricks.com/regarding-css-global-scope/), you can unintentionally target too many elements.
- **Colocation.** It's hard to modularize your CSS, which makes it difficult to delete code safely.

At this point, I was introduced to [CSS pre-processors](https://developer.mozilla.org/en-US/docs/Glossary/CSS_preprocessor).
These tools aim to introduce new funtionality and compile back to vanilla CSS.

## Sass

[Sass](https://sass-lang.com/), one of the most popular preprocessors, allows you to write more reusable, maintainable CSS.
Some of the most popular features are [variables](https://sass-lang.com/documentation/variables), [mixins](https://sass-lang.com/documentation/at-rules/mixin), and [modules](https://sass-lang.com/documentation/modules).

- **Variables.** I want to define global values once and share them throughout my stylesheets.
- **Mixins.** I want to reuse particular snippets of CSS.
- **Modules.** I want to split up my CSS files for a more maintainable codebase.

```scss:_base.scss
$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
}
```

```scss:_header.scss
@use 'base';

.header {
  font-size: 32px;
}
```

Sass helped me write more modular, reusable CSS – at least, for a while. Over time, I ran into new issues.

- **Naming.** As your CSS grows, it's easy to have class names get out of hand.
- **Browser support.** Certain features aren't [supported across all browsers](https://caniuse.com/) and require [vendor prefixes](https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix) like `-moz-` (Firefox), `-webkit-` (Safari), and `-ms-` (Internet Explorer and Edge).

To solve naming, I started to adopt [BEM](http://getbem.com/introduction/).
Block Element Modifier is a methodology that helps you to create reusable components
and organize CSS in a modular way, which keeps specificity low.

```html
<button class="button">Cancel</button>
<button class="button button--primary">Submit</button>
```

```css
.button {
  color: black;
  background-color: gray;
}

.button--primary {
  color: white;
  background-color: green;
}
```

Naming conventions helped but didn't fix the root cause: **naming is hard**.
For browser support, it's possible to set up your Sass toolchain with a tool like [autoprefixer](https://css-tricks.com/autoprefixer/) to handle vendor prefixes.
However, around this time, I started using component-based frameworks like React. This led me to explore CSS-in-JS.

## CSS-in-JS

My first adventure with CSS-in-JS: building a [component library with styled-components](/blog/ui-component-library-with-styled-components). At first, CSS-in-JS solved all my problems.

- **Specificity** is solved by auto-generated class names.
- **Colocation** is solved by putting CSS directly with the component, making it easy to delete code.
- **Browser support** is solved by having autoprefixer built-in.
- **Variables** are solved by creating a global theme.

However, **naming** was still a huge pain.

As the component library grew, I began to explore [Theme UI](https://theme-ui.com) and [styled-system](https://styled-system.com/).
These were more structured approaches to scaling CSS-in-JS to help enforce a design system.
Plus, they helped solve naming. Trying to scale [styled-components](https://styled-components.com/) alone in a large application made me get _really_ creative with names.
You can only have so many container, wrapper, layout things. For example:

```js
const HomeContainerWrapper = styled.div`
   padding: 8px;
   font-weight: bold;
   color: white;
   background: blue;
`;

<HomeContainerWrapper>
  Hello
</HomeContainerWrapper>

// Forget about naming
<Box
  padding={3}
  fontWeight='bold'
  color='white'
  bg='blue'
>
  Hello
</Box>
```

Now, I know what you're thinking. Inline styles 🤮. I'll admit, I wasn't sold at first. But it grew on me – and that brings us to now.

## Current State

I've recently been working with [CSS Modules](https://github.com/css-modules/css-modules) and [Tailwind CSS](https://tailwindcss.com/).
Both of these approaches to styling React applications have prompted me to step back and evaluate the ecosystem.

Below, I've summarized pros and cons of various approaches to styling your React application. I tried to make this comparison as unopinionated as possible.
The choice that's best for you likely depends on:

- Your experience (stick with what you know).
- Your team.
- The size of your application.
- What you're trying to build.

## Pros and Cons

### Vanilla CSS

<Pros
  title="vanilla CSS"
  list={[
    `You don't want to add a toolchain. Vanilla CSS works with every browser & language.`,
  ]}
/>

<Cons title="vanilla CSS" list={[`You're building a large web application.`]} />

### CSS Modules

[CSS Modules](https://github.com/css-modules/css-modules) would be my choice for smaller teams that don't need to share
components across applications.

[Next.js](https://nextjs.org) has support for CSS Modules, which means you don't have to worry about setting up [Webpack](https://webpack.js.org/).
It also sets up [autoprefixer](https://css-tricks.com/autoprefixer/) making CSS Modules an attractive alternative to CSS-in-JS in some cases.

<Pros
  title="CSS modules"
  list={[
    "You want class names scoped to the corresponding component.",
    "You want to use CSS variables to reuse values.",
    "You need your application to work without JavaScript.",
    "You want the lowest barrier to entry.",
    "You want to use any language, not just JavaScript.",
  ]}
/>

<Cons
  title="CSS modules"
  list={[
    `You don't want to configure a toolchain like Webpack.`,
    "You need to distribute a package on NPM.",
    "You want nesting support by default (requires PostCSS).",
    `You don't want to context switch between files.`,
  ]}
/>

### CSS-in-JS

There's many different CSS-in-JS libraries. The two most popular are [styled-components](https://styled-components.com/) and [Emotion](https://emotion.sh/docs/introduction).

There's also zero-runtime solutions like [Linaria](https://github.com/callstack/linaria), where CSS is extracted to CSS files at build-time.
To see comparisons between different libraries, see [CSS-in-JS benchmarks.](https://github.com/A-gambit/CSS-IN-JS-Benchmarks)

<Pros
  title="CSS-in-JS"
  list={[
    "You want to distribute as reusable components on NPM.",
    "You want to take advantage of anything in the JavaScript ecosystem.",
    "You want to colocate styles with components, making it easy to delete code.",
    "You need to support multiple themes.",
  ]}
/>

<Cons
  title="CSS-in-JS"
  list={[
    `You don't want to configure a toolchain like Webpack.`,
    "You are sick of figuring out names for things.",
    "You believe it breaks separation of concerns.",
    `You don't want to enforce all consumers must use the same CSS-in-JS solution.`,
  ]}
/>

### Theme UI / Styled System

Both [Theme UI](https://theme-ui.com) and [styled-system](https://styled-system.com/) abide by the [System UI theme specification](https://system-ui.com/).
This specification intends to help make UI components, libraries, and tools as interoperable as possible.

The primary use case for these libraries is implenting a component library and design system.
One of my favorite libraries is [Chakra UI](https://next.chakra-ui.com/).

<Pros
  title="Theme UI / styled-system"
  list={[
    `You're building a component library.`,
    "You need to enforce a design system.",
    "You want to spend less time trying to name components.",
  ]}
/>

<Cons
  title="Theme UI / styled-system"
  list={[
    "You dislike providing styles as props.",
    "You believe it breaks separation of concerns.",
  ]}
/>

### Tailwind CSS

[Tailwind CSS](https://tailwindcss.com/) has been rapidly growing in popularity. Many people are frustrated with the bloat of CSS frameworks like
[Bootstrap](https://getbootstrap.com/) and want an alternative. Tailwind provides an impressive developer experience with a refined API.

With the combination of [Tailwind UI](https://tailwindui.com/), you can easily build extensible, well-designed applications.

<Pros
  title="Tailwind"
  list={[
    "You want to never leave your HTML (or JSX).",
    "You need to enforce a design system.",
    "You want to spend less time trying to name components.",
  ]}
/>

<Cons
  title="Tailwind"
  list={[
    `You don't want (potentially) long class names.`,
    `You don't want to learn Tailwind syntax, which is slightly different than standard CSS.`,
  ]}
/>

## Conclusion

I hope this article has helped demystify styling your React applications. Did I miss anything or see something you'd change?
Leave a comment below or reach out on [Twitter](https://twitter.com/leeerob).

## Further Reading

- [Switching to Tailwind CSS](/blog/tailwind)
- [What are CSS Modules and why do we need them?](https://css-tricks.com/css-modules-part-1-need/)
- [The Cost of JavaScript in 2019](https://v8.dev/blog/cost-of-javascript-2019)
- [CSS-in-JS library comparisons](https://github.com/andreipfeiffer/css-in-js)
- [Refactoring an alert component from CSS to CSS-in-JS](https://alert-refactor.netlify.app/)
- [Two Steps Forward, One Step Back](https://jxnblk.com/blog/two-steps-forward/)

---

[This is eight post](https://leerob.io/blog/rust)

---

[Rust](https://www.rust-lang.org/) is a fast, reliable, and memory-efficient programming language. It's been voted the most loved programming language [six](https://insights.stackoverflow.com/survey/2016#technology-most-loved-dreaded-and-wanted) [years](https://insights.stackoverflow.com/survey/2017#most-loved-dreaded-and-wanted) [in](https://insights.stackoverflow.com/survey/2018#technology-_-most-loved-dreaded-and-wanted-languages) [a](https://insights.stackoverflow.com/survey/2019#technology-_-most-loved-dreaded-and-wanted-languages) [row](https://insights.stackoverflow.com/survey/2020#most-loved-dreaded-and-wanted) ([survey](https://insights.stackoverflow.com/survey/2021/#technology-most-loved-dreaded-and-wanted)). Created by Mozilla, it's now used at [Facebook](https://engineering.fb.com/2021/04/29/developer-tools/rust/), [Apple](https://twitter.com/oskargroth/status/1301502690409709568), [Amazon](https://aws.amazon.com/blogs/opensource/why-aws-loves-rust-and-how-wed-like-to-help/), [Microsoft](https://twitter.com/ryan_levick/status/1171830191804551168), and [Google](https://security.googleblog.com/2021/04/rust-in-android-platform.html) for systems infrastructure, encryption, virtualization, and more low-level programming.

Why is Rust now being used to replace parts of the JavaScript web ecosystem like minification (Terser), transpilation (Babel), formatting (Prettier), bundling (webpack), linting (ESLint), and more?

> Note: This post is also available in [Chinese](https://mp.weixin.qq.com/s?__biz=MzkxNDIzNTg4MA==&mid=2247485792&idx=1&sn=682a4dee7ce4d3b47a81baf9ebd7a98a&chksm=c170c1e7f60748f17585d6bfca0cff6edbf71bab95f0a4a1ea0bcf2d43c16d1722666d9fadc1&token=1766743281&lang=zh_CN#rd), [Portuguese](https://codigofonte.com.br/artigos/rust-e-o-futuro-da-infraestrutura-javascript), and [Arabic](https://www.tutomena.com/rust-and-javascript/).

## What is Rust?

Rust helps developers write fast software that's memory-efficient. It's a modern replacement for languages like C++ or C with a focus on code safety and concise syntax.

Rust is quite different than JavaScript. JavaScript tries to find variables or objects not in use and automatically clears them from memory. This is called [Garbage Collection](<https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)>). The language abstracts the developer from thinking about manual memory management.

With Rust, developers have more control over memory allocation, without it being as painful as C++.

> Rust uses a relatively unique memory management approach that incorporates the idea of memory “ownership”. Basically, Rust keeps track of who can read and write to memory. It knows when the program is using memory and immediately frees the memory once it is no longer needed. It enforces memory rules at compile time, making it virtually impossible to have runtime memory bugs. You do not need to manually keep track of memory. The compiler takes care of it. – [Discord](https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f)

## Adoption

On top of the companies mentioned above, Rust is also being used for popular open-source libraries like:

- [Firecracker](https://github.com/firecracker-microvm/firecracker) (AWS)
- [Bottlerocket](https://github.com/bottlerocket-os/bottlerocket) (AWS)
- [Quiche](https://github.com/cloudflare/quiche) (Cloudflare)
- [Neqo](https://github.com/mozilla/neqo) (Mozilla)

> Rust has been a force multiplier for our team, and betting on Rust was one of the best decisions we made. More than performance, its ergonomics and focus on correctness has helped us tame sync’s complexity. We can encode complex invariants about our system in the type system and have the compiler check them for us. – [Dropbox](https://dropbox.tech/infrastructure/rewriting-the-heart-of-our-sync-engine)

## From JavaScript to Rust

JavaScript is the most widely used programming language, operating on every device with a web browser. Over the past ten years, a massive ecosystem has been built around JavaScript:

- **Webpack:** developers wanted to bundle multiple JavaScript files into one.
- **Babel:** developers wanted to write modern JavaScript while supporting older browsers.
- **Terser:** developers wanted to generate the smallest possible file sizes.
- **Prettier:** developers wanted an opinionated code formatter that just worked.
- **ESLint:** developers wanted to find issues with their code before deploying.

Millions of lines of code have been written and even more bugs have been fixed to create the bedrock for shipping web applications of today. All of these tools are written with JavaScript or TypeScript. This has worked well, but we've reached peak optimization with JS. This has inspired a new class of tools, designed to drastically improve the performance of building for the web.

### SWC

[SWC](http://swc.rs/), created in 2017, is an extensible Rust-based platform for the next generation of fast developer tools. It's used by tools like Next.js, Parcel, and Deno, as well as companies like Vercel, ByteDance, Tencent, Shopify, and more.

SWC can be used for compilation, minification, bundling, and more – and is designed to be extended. It's something you can call to perform code transformations (either built-in or custom). Running those transformations happens through higher-level tools like Next.js.

### Deno

[Deno](https://deno.land/), created in 2018, is a simple, modern, and secure runtime for JavaScript and TypeScript that uses [V8](https://v8.dev/) and is built with Rust. It's an attempt to replace Node.js, written by the original creators of Node.js. While it was created in 2018, it didn't hit [v1.0 until May 2020](https://deno.com/blog/v1).

Deno’s linter, code formatter, and docs generator are [built using SWC](https://twitter.com/devongovett/status/1369033422002389000).

### esbuild

[esbuild](https://esbuild.github.io/), created in January 2020, is a JavaScript bundler and minifier 10-100x faster than existing tools, written in Go.

> I'm trying to create a build tool that A) works well for a given sweet spot of use cases (bundling JavaScript, TypeScript, and maybe CSS) and B) **resets the expectations of the community for what it means for a JavaScript build tool to be fast**. Our current tools are way too slow in my opinion. – Evan, Creator of esbuild ([Source](https://news.ycombinator.com/item?id=22336334))

Building JavaScript tooling with systems programming languages, like Go and Rust, was fairly niche until esbuild was released. In my opinion, esbuild sparked a wider interest in trying to make developer tools faster. Evan chose to use Go:

> The Rust version probably could be made to work at an equivalent speed with enough effort. But at a high level, Go was much more enjoyable to work with. This is a side project and it has to be fun for me to work on it. – Evan, Creator of esbuild ([Source](https://news.ycombinator.com/item?id=22336284))

Some argue Rust could perform better, but both could achieve Evan's original goal of influencing the community:

> Even with just basic optimization, Rust was able to outperform the hyper hand-tuned Go version. This is a huge testament to how easy it is to write efficient programs with Rust compared to the deep dive we had to do with Go. – [Discord](https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f)

### Rome

[Rome](https://rome.tools/blog/2020/08/08/introducing-rome), created in August 2020, is a linter, compiler, bundler, test runner, and more, for JavaScript, TypeScript, HTML, JSON, Markdown, and CSS. They aim to replace and unify the entire frontend development toolchain. It's created by [Sebastian](https://twitter.com/sebmck), who also created Babel.

Why rewrite everything, then?

> Making the necessary modifications to Babel to allow for it to be a reliable base for other tools would have required changes to absolutely everything. The architecture is bound to the initial design choices I made in 2014 when I was learning about parsers, ASTs, and compilers. - Sebastian ([Source](https://rome.tools/blog/2020/08/08/introducing-rome))

Rome is currently written in TypeScript and runs on Node.js. But they're now working on [rewriting in Rust](https://rome.tools/blog/2021/09/21/rome-will-be-rewritten-in-rust) using RSLint parser and their own visitor system for AST traversal.

### NAPI

Rust’s integration with Node.js is better than other low-level languages.

[napi-rs](https://napi.rs/) allows you to build pre-compiled Node.js add-ons with Rust. It provides an out-of-the-box solution for cross-compilation and publishing native binaries to NPM, without needing `node-gyp` or `postinstall` scripts.

You can build a Rust module that can be called directly from Node.js, without needing to create a child process like esbuild.

## Rust + WebAssembly

[WebAssembly](https://webassembly.org/docs/use-cases/) *(*WASM*)* is a portable low-level language that Rust can compile to. It runs in the browser, is interoperable with JavaScript, and is supported in all major modern browsers.

> WASM is definitely a lot faster than JS, but not quite native speed. In our tests, Parcel runs 10-20x slower when compiled to WASM than with native binaries. – [Devon Govett](https://twitter.com/devongovett)

While WASM isn't the perfect solution yet, it _can_ help developers create extremely fast web experiences. The Rust team is [committed](https://www.rust-lang.org/what/wasm) to a high-quality and cutting-edge WASM implementation. For developers, this means you could have the performance advantages of Rust (vs. Go) while still compiling for the web (using WASM).

Some early libraries and frameworks in this space:

- [Yew](https://yew.rs/)
- [Percy](https://github.com/chinedufn/percy)
- [Seed](https://github.com/seed-rs/seed)
- [Sycamore](https://github.com/sycamore-rs/sycamore)
- [Stork](https://stork-search.net/)

These Rust-based web frameworks that compile to WASM aren't trying to replace JavaScript, but work alongside it. While we aren't there yet, it's interesting to see Rust coming after the web on both sides: **making existing JavaScript tooling faster** _and_ **future-forward ideas for [compiling to WASM](https://rustwasm.github.io/docs/book/introduction.html)**.

It's Rust all the way down.

## Why Not Rust?

Rust has a steep learning curve. It's a lower level of abstraction than what most web developers are used to.

Once you're on native code (through Rust, Go, Zig, or other low-level languages),
the algorithms and data structures are [more important](https://twitter.com/devongovett/status/1457945506332692482) than the language choice. It's not a silver bullet.

> Rust makes you think about dimensions of your code that matter tremendously for systems programming. It makes you think about how memory is shared or copied. It makes you think about real but unlikely corner cases and make sure that they’re handled. It helps you write code that’s incredibly efficient in every possible way. – Tom MacWright ([Source](https://macwright.com/2021/01/15/rust.html))

Further, Rust's usage in the web community is still niche. It hasn't reached critical adoption. Even though learning Rust for JavaScript tooling will be a barrier to entry, interestingly developers would rather have a [faster tool that's harder to contribute to](https://twitter.com/devongovett/status/1261379312898306048). [Fast software wins](https://craigmod.com/essays/fast_software/).

Currently, it's hard to find a Rust library or framework for your favorite services (things like working with authentication, databases, payments, and more). I do think that once Rust and WASM reach critical adoption, this will resolve itself. But not yet. **We need existing JavaScript tools to help us bridge the gap and incrementally adopt performance improvements**.

## The Future of JavaScript Tooling

I believe Rust is the future of JavaScript tooling. [Next.js 12](http://nextjs.org/12) started our transition to fully replace Babel (transpilation) and Terser (minification) with SWC and Rust. Why?

- **Extensibility:** SWC can be used as a Crate inside Next.js, without having to fork the library or workaround design constraints.
- **Performance:** We were able to achieve ~3x faster Fast Refresh and ~5x faster builds in Next.js by switching to SWC, with more room for optimization still in progress.
- **WebAssembly:** Rust's support for WASM is essential for supporting all possible platforms and taking Next.js development everywhere.
- **Community:** The Rust community and ecosystem are amazing and only growing.

It's not just Next.js adopting SWC, either:

- [Deno’s](https://deno.land/) linter, code formatter, and docs generator are [built using SWC](https://twitter.com/devongovett/status/1369033422002389000).
- [dprint](https://github.com/devongovett/dprint-node), built on SWC, is a [30x faster](https://twitter.com/devongovett/status/1400138335721455617) code formatting replacement for Prettier.
- [Parcel](https://parceljs.org/) improved overall build performance by [up to 10x](https://v2.parceljs.org/blog/beta3/) with SWC.

> Parcel uses SWC like a library. Before we used Babel's parser and custom transforms written in JS. Now, we use SWC's parser and [custom transforms in Rust](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/js/core/src). This includes a full scope hoisting implementation, dependency collection, and more. It's similar in scope to how Deno built on top of SWC. – [Devon Govett](https://twitter.com/devongovett)

It's early days for Rust – a few important pieces are still being figured out:

- **Plugins:** Writing plugins in Rust isn't as approachable for many JavaScript developers. At the same time, exposing a plugin system in JavaScript could negate performance gains. A definitive solution hasn't emerged yet. Ideally, the future combines both JavaScript and Rust. If you want to write a plugin with JavaScript, it’s possible with a tradeoff for speed. Need more performance? Use the Rust plugin API.
- **Bundling:** One interesting area of development is `swcpack`, which is SWC's replacement for Webpack. It's still under development but could be very promising.
- **WebAssembly:** As mentioned above, the prospect of writing Rust and compiling to WASM is enticing, but there's still work to be done.

Regardless, I'm confident Rust will continue to have a major impact on the JavaScript ecosystem for the next 1-2 years and into the future. Imagine a world where all of the build tools used in Next.js are written in Rust, giving you optimal performance. Then, Next.js could be distributed as a [static binary](https://en.wikipedia.org/wiki/Static_build) you'd download from NPM.

That's the world I want to live (and develop) in.

---

_Thanks to [Devon Govett](https://twitter.com/devongovett) for reviewing an early draft of this article._
